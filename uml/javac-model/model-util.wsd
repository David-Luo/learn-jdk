@@startuml model-util

interface Types {
+ Element asElement(TypeMirror t)
+ boolean isSameType(TypeMirror t1, TypeMirror t2)
+ boolean isSubtype(TypeMirror t1, TypeMirror t2)
+ boolean isAssignable(TypeMirror t1, TypeMirror t2)
+ boolean contains(TypeMirror t1, TypeMirror t2)
+ boolean isSubsignature(ExecutableType m1, ExecutableType m2)
+ List<? extends TypeMirror> directSupertypes(TypeMirror t)
+ TypeMirror erasure(TypeMirror t)
+ TypeElement boxedClass(PrimitiveType p)
+ PrimitiveType unboxedType(TypeMirror t)
+ TypeMirror capture(TypeMirror t)
+ PrimitiveType getPrimitiveType(TypeKind kind)
+ NullType getNullType()
+ NoType getNoType(TypeKind kind)
+ ArrayType getArrayType(TypeMirror componentType)
+ WildcardType getWildcardType(TypeMirror extendsBound,TypeMirror superBound)
+ DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs)
+ DeclaredType getDeclaredType(DeclaredType containing,TypeElement typeElem, TypeMirror... typeArgs)
+ TypeMirror asMemberOf(DeclaredType containing, Element element)
}

interface Elements {
+ PackageElement getPackageElement(CharSequence name)
+ default PackageElement getPackageElement(ModuleElement module, CharSequence name)
+ default Set<? extends PackageElement> getAllPackageElements(CharSequence name)
+ TypeElement getTypeElement(CharSequence name)
+ default TypeElement getTypeElement(ModuleElement module, CharSequence name)
+ default Set<? extends TypeElement> getAllTypeElements(CharSequence name) 
+ default ModuleElement getModuleElement(CharSequence name) 
+ default Set<? extends ModuleElement> getAllModuleElements()
+ Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValuesWithDefaults(AnnotationMirror a)
+ String getDocComment(Element e)
+ boolean isDeprecated(Element e)
+ default Origin getOrigin(Element e) 
+ default Origin getOrigin(AnnotatedConstruct c,AnnotationMirror a)
+ default Origin getOrigin(ModuleElement m,ModuleElement.Directive directive) 
+ default boolean isBridge(ExecutableElement e)Name getBinaryName(TypeElement type)
+ PackageElement getPackageOf(Element e)
+ default ModuleElement getModuleOf(Element e)
+ List<? extends Element> getAllMembers(TypeElement type)
+ List<? extends AnnotationMirror> getAllAnnotationMirrors(Element e)
+ boolean hides(Element hider, Element hidden)
+ boolean overrides(ExecutableElement overrider, ExecutableElement overridden,TypeElement type)
+ String getConstantExpression(Object value)
+ void printElements(java.io.Writer w, Element... elements)
+ Name getName(CharSequence cs)
+ boolean isFunctionalInterface(TypeElement type)
+ default RecordComponentElement recordComponentFor(ExecutableElement accessor) {

}
class ElementFilter{
     + {static} List<VariableElement> fieldsIn(Iterable<? extends Element> elements)
     + {static} List<ExecutableElement> constructorsIn(Iterable<? extends Element> elements)
     + {static} List<ExecutableElement> methodsIn(Iterable<? extends Element> elements)
     + {static} List<TypeElement> typesIn(Iterable<? extends Element> elements)
}

interface TypeVisitor<R, P> {
    + R visit(TypeMirror t, P p)
    + R visitPrimitive(PrimitiveType t, P p)
    + R visitNull(NullType t, P p)
    + R visitArray(ArrayType t, P p)
    + R visitDeclared(DeclaredType t, P p)
}

interface ElementVisitor<R, P>{
    R visit(Element e, P p)
    R visitPackage(PackageElement e, P p)
    R visitType(TypeElement e, P p)
    R visitVariable(VariableElement e, P p)
    R visitExecutable(ExecutableElement e, P p)
    R visitTypeParameter(TypeParameterElement e, P p)
    R visitUnknown(Element e, P p)
}
@@enduml